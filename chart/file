---
# Source: polykube/templates/05-namespace.yaml
---
apiVersion: v1
kind: Namespace
metadata:
  name: "polykube"
---



apiVersion: v1
kind: Secret
type: "kubernetes.io/dockercfg"
metadata:
  name: "acr-image-pull-secret"
  namespace: "polykube"
data:
  .dockercfg: eyJzZXJ2ZXIiOnsidXNlcm5hbWUiOiJub25lIiwicGFzc3dvcmQiOiJub25lIiwiZW1haWwiOiJuYUBleGFtcGxlLmNvbSIsImF1dGgiOiJub25lOm5vbmUifX0=

---
# Source: polykube/templates/20-postgres.yaml
---
kind: Secret
apiVersion: v1
metadata:
  name: postgres
  namespace: polykube
  labels:
    chart: "polykube-0.1.0"
type: Opaque
data:
  
  password: "ZjY5UHZHRjFuSjNENERi"
  
---
kind: Deployment
apiVersion: extensions/v1beta1
metadata:
  name: postgres
  namespace: polykube
  labels:
    chart: "polykube-0.1.0"
spec:
  replicas: 1
  template:
    metadata:
      namespace: polykube
      labels:
        name: postgres
        chart: "polykube-0.1.0"
    spec:
      imagePullSecrets:
      - name: acr
      containers:
      - name: postgres
        image: docker.io/colemickens/polykube-postgres:stable
        imagePullPolicy: Always
        env:
        - name: POSTGRES_PASSWORD
          valueFrom:
            secretKeyRef:
              name: postgres
              key: password
---
kind: Service
apiVersion: v1
metadata:
  name: postgres
  namespace: polykube
  labels:
    chart: "polykube-0.1.0"
spec:
  selector:
    name: postgres
  ports:
  - port: 5432
    targetPort: 5432

---
# Source: polykube/templates/20-redis.yaml
---
kind: Secret
apiVersion: v1
metadata:
  name: redis
  namespace: polykube
  labels:
    chart: "polykube-0.1.0"
type: Opaque
data:
  
  password: "YVk5MWdHcjNqa2thM1ky"
  
---
kind: Deployment
apiVersion: extensions/v1beta1
metadata:
  name: redis
  namespace: polykube
  labels:
    chart: "polykube-0.1.0"
spec:
  replicas: 1
  template:
    metadata:
      namespace: polykube
      labels:
        name: redis
        chart: "polykube-0.1.0"
    spec:
      imagePullSecrets:
      - name: acr
      containers:
      - name: redis
        image: docker.io/colemickens/polykube-redis:stable
        imagePullPolicy: Always
        env:
        - name: REDIS_PASSWORD
          valueFrom:
            secretKeyRef:
              name: redis
              key: password
        ports:
        - containerPort: 6379
---
kind: Service
apiVersion: v1
metadata:
  name: redis
  namespace: polykube
  labels:
    chart: "polykube-0.1.0"
spec:
  selector:
    name: redis
  ports:
  - port: 6379
    targetPort: 6379

---
# Source: polykube/templates/05-nginx.yaml
---
apiVersion: v1
kind: Service
metadata:
  name: "nginx"
  namespace: "polykube"
spec:
  type: LoadBalancer
  ports:
  - port: 80
    name: http
  - port: 443
    name: https
  selector:
    app: nginx
---
apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  name: default-http-backend
  namespace: polykube
spec:
  replicas: 3
  template:
    metadata:
      labels:
        app: 'default-http-backend'
    spec:
      terminationGracePeriodSeconds: 60
      containers:
      - name: default-http-backend
        # Any image is permissable as long as:
        # 1. It serves a 404 page at /
        # 2. It serves 200 on a /healthz endpoint
        image: gcr.io/google_containers/defaultbackend:1.0
        livenessProbe:
          httpGet:
            path: /healthz
            port: 8080
            scheme: HTTP
          initialDelaySeconds: 30
          timeoutSeconds: 5
        ports:
        - containerPort: 8080
        resources:
          limits:
            cpu: 10m
            memory: 20Mi
          requests:
            cpu: 10m
            memory: 20Mi

---
# Source: polykube/templates/30-aspnet-api.yaml
---
kind: Deployment
apiVersion: extensions/v1beta1
metadata:
  name: "aspnet-api"
  namespace: "polykube"
  labels:
    chart: "polykube-0.1.0"
spec:
  replicas: 3
  template:
    metadata:
      namespace: polykube
      labels:
        name: "aspnet-api"
        chart: "polykube-0.1.0"
    spec:
      imagePullSecrets:
      - name: acr
      containers:
      - name: aspnet-api
        image: docker.io/colemickens/polykube-aspnet-api:stable
        imagePullPolicy: Always
        env:
        - name: LISTEN_HOST
          value: '0.0.0.0'
        - name: LISTEN_PORT
          value: '8000'
        - name: REDIS_ADDRESS
          value: 'redis'
        - name: REDIS_PORT
          value: '6379'
        - name: REDIS_PASSWORD
          valueFrom:
            secretKeyRef:
              name: redis
              key: password
        - name: DATABASE_DRIVER
          value: 'postgres'
        - name: DATABASE_NAME
          value: 'polykubedb'
        - name: POSTGRES_ADDRESS
          value: 'postgres'
        - name: POSTGRES_PORT
          value: '5432'
        - name: POSTGRES_USERNAME
          value: 'postgres'
        - name: POSTGRES_PASSWORD
          valueFrom:
            secretKeyRef:
              name: postgres
              key: password
        ports:
        - containerPort: 8000
        readinessProbe:
          httpGet:
            path: /info
            port: 8000
          initialDelaySeconds: 10
          timeoutSeconds: 1
        livenessProbe:
          httpGet:
            path: /info
            port: 8000
          initialDelaySeconds: 10
          timeoutSeconds: 1
      - name: aspnet-nginx
        image: docker.io/colemickens/polykube-aspnet-api-nginx:stable
        imagePullPolicy: Always
        env:
        - name: LISTEN_PORT
          value: '80'
        - name: BACKEND_LOCATION
          value: 'http://0.0.0.0:8000'
        ports:
        - containerPort: 80
---
kind: Service
apiVersion: v1
metadata:
  name: "aspnet-api"
  namespace: "polykube"
  labels:
    chart: "polykube-0.1.0"
spec:
  selector:
    name: "aspnet-api"
    chart: "polykube-0.1.0"
  ports:
  - port: 80
    targetPort: 80

---
# Source: polykube/templates/40-frontend.yaml
---
kind: Deployment
apiVersion: extensions/v1beta1
metadata:
  name: frontend
  namespace: "polykube"
  labels:
    chart: "polykube-0.1.0"
spec:
  replicas: 3
  template:
    metadata:
      namespace: "polykube"
      labels:
        name: "frontend"
        chart: "polykube-0.1.0"
    spec:
      imagePullSecrets:
      - name: acr
      containers:
      - name: frontend
        image: docker.io/colemickens/polykube-frontend:stable
        imagePullPolicy: Always
        ports:
        - containerPort: 80
---
kind: Service
apiVersion: v1
metadata:
  name: "frontend"
  namespace: "polykube"
  labels:
    chart: "polykube-0.1.0"
spec:
  selector:
    name: "frontend"
    chart: "polykube-0.1.0"
  ports:
  - port: 80
    targetPort: 80

---
# Source: polykube/templates/10-ingress.yaml
---
apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  name: polykube
  namespace: polykube
  labels:
    chart: "polykube-0.1.0"
  annotations:
    kubernetes.io/tls-acme: "true"
    stable.k8s.psg.io/kcm.enabled: "true"
    stable.k8s.psg.io/kcm.enabled: "http"
    stable.k8s.psg.io/kcm.enabled: "admin@polykube.io"
spec:
  tls:
  - hosts:
    - api.polykube.io
    - polykube.io
    secretName: polykube-tls
  rules:
  - host: polykube.io
    http:
      paths:
      - path: /
        backend:
          serviceName: frontend
          servicePort: 80
  - host: api.polykube.io
    http:
      paths:
      - path: /
        backend:
          serviceName: aspnet-api
          servicePort: 80

---
# Source: polykube/templates/05-kcm.yaml
---
apiVersion: extensions/v1beta1
kind: ThirdPartyResource
description: "A specification of a Let's Encrypt Certificate to manage."
metadata:
  name: "certificate.stable.k8s.psg.io"
versions:
  - name: v1
---
apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  labels:
    app: 'kube-cert-manager'
  name: 'kube-cert-manager'
spec:
  replicas: 1
  template:
    metadata:
      labels:
        app: 'kube-cert-manager'
      name: 'kube-cert-manager'
    spec:
      containers:
        - name: kube-cert-manager
          image: palmstonegames/kube-cert-manager:0.3.1
          args:
            - "-data-dir=/var/lib/cert-manager"
            - "-acme-url=https://acme-staging.api.letsencrypt.org/directory"
            # NOTE: the URL above points to the staging server, where you won't get real certs.
            # Uncomment the line below to use the production LetsEncrypt server:
            #- "-acme-url=https://acme.api.letsencrypt.org/directory"
            #volumeMounts:
            #- name: data
            #  mountPath: /var/lib/cert-manager
        - name: kubectl-proxy
          image: palmstonegames/kubectl-proxy:1.4.0
            #volumes:
            #- name: "data"
            #emptyDir: {}
          #gcePersistentDisk:
          #  pdName: kube-cert-manager
          #fsType: ext4

